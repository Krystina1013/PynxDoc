# 传输框架说明
系统中有三种类型的数据传输：
1. 邻节点推送，节点向自身的某个邻节点推送数据
2. P2P传输，节点向指定地址的节点传输数据


## 邻节点推送算法
### 推/拉算法说明
考虑节点A、B和C，A向B和C发送某个数据块，经过一段时间的延时后，B转发此数据区给C，但此时C已经收到过A发送的数据了，因此这个数据再发送一次是没有意义的。

我们使用如下的方案，当A需要向B发送数据时，A首先向B发送到一个数据传输请求，这个请求里包含了待发送数据块的哈希值，B收到这个请求后，本地检测哈希对应的数据块是否存在，只有当这个数据块不存在时，才会向A请求此数据，因此包含四个步骤：
1.  A 向 B发送 {pushhash,hash}
2.  B 向 A请求 {pullhash,hash}
3.  A 向 B发送 {pushdata,hash,data}
4.  B 验证 Hash(data) == hash

通过这个方式，使数据不会重复传输
### 实现
定义一个


## 点到点传输算法说明

假设有如下的网络拓扑：

![](route.png)
### 路由管理

#### 发现请求
1. 当B需要发送数据给H时，从邻节点中寻找$\alpha$个离H更近的节点，向这$\alpha$个中继节点发送数据数据中继请求
```json
    {
            createTime:xxx, //此路由的请求时间 
            dest:H,      //目标地址，此处为H
            alpha:3,     //扩散值 
            path:None,   //源路径为空
            orgTTL:v      //初始TTL值，
            sign:sb      // B的签名

    }
```
注意这里的orgTTL和alpha与需要支持的费用相关，这个在后面的付费路由中详细描述

2. 在图中，B找到了C/D,当C/D收到此中继请求时，记录请求来源者B，然后生成一个新的路由请求：
```
    {
            createTime:xxx, //此路由的请求时间 
            dest:H,      //目标地址，此处为H
            alpha:3,     //扩散值 
            path:[B],   //源路径为空
            orgTTL:v-1      //初始TTL值，
            sign:sc      // B的签名

    }
```
与1相比，增加了path的信息，以及orgTTL-1，同时签名改成了sc,sc是具有线性特点的bls签名，即 sc = sign<sub>c</sub>(createTime)+sb。
3. 查看节点F,节点将收到来自C和D的两次路由发现请求，在第二次收到请求时，只记录路由发现的请求者C/D，等到H的回应到达后，再将回应分别发送给C/D
4. H收到E/F/G来的请求，发现是自身，通EFG向B发送回应
   
#### 发现回应
1. 发现回应过程中，节点只向上次向自己发送发现请求的节点传播数据
3. 由于节点都是不可信的，因此有可能中间的路由节点会造假，为了防止造假，节点回应的路由信息中，需要有路由目标地址的签名和中间所有中继的签名,在第一个版本中，为了简化开发，要求必须记录从上一节点到目标节点的所有签名，假设我们从B发送了到H的路由请求，然后从H返回此路由回应。
   1. H向E、F、G发送经过签名的路由回应`{createTime:xxx,ttl:0,path:[None],sign:sh}`此处的sh是h对createTime的bls签名；
   2. E/F中记录路由信息，E中
        ```json
        {
   
            minttl:1,
            pathes:[{createTime:xxx,next:H,path:None}],
            sign:se
         }
        ```
        和F中：
        ```
        { 
            minttl:1,
            pathes:[{createTime:xxx,next:H,path:None}],
            sign:sf
        }
        ```
        此处的se是e对createTime签名`se'+sh`,由于`bls`签名的线性，这个签名是可验证的。sf同理,此处把自己的签名直接生成加入，免得每次路由查询的时候需要重新生成
   3. E向C发送路由回应
        ```
        {
            createTime:xxx,
            pathes:[{next:H,pathes:None}],
            sign:se
        }
        ```
   4. F向C发送路由回应
    ```
        {
            createTime:xxx,
            path:[{next:H,pathes:None}],
            sign:sf
        }
    ````  
   5. C收到两条路由回应后，形成一条具有两条路径到H的记录,此处的sc同样是bls签名,可以通过E+F+H+C的公钥进行验证
    ```
    {   
        minttl:2,
        nexthops:[
            {next:E,createTime:xxx,pathes:[next:H,path:[None]],sign:se},
            {next:F,createTime:xxx,pathes:[next:H,path:[None]],sign:sf}
            ],
        sign:sc
    }
    ```
    为了简化起见，我们定义总表项数为ALPHA=3，当有第四个createTime的路由需要更新时，删除createTime最早的那个.
   6. C向B回应路由消息
    ```json
    {
        createTime:xxx,
        pathes:[
            {next:E,path:[{next:H,path:[None]}]},
            {next:F,path:[{next:H,path:[None]}]}
            ],
            sign:sc
    }
    ```
   7. D同样向B回应路由信息
   ```json
    {
        createTime:xxx,
        pathes:[
            {next:H,path:[None]},
            {next:F,path:[{next:H,path:[None]}]}
            ],
        sign:sd
    }
   ```
   1. B中形成路由信息
    ```json
      {
        nexthops:[
        {
               createTime:xxx,
            next:C,
             minttl:2,
            path: [
                {next:E,path:[{next:H,path:[None]}]},
                {next:F,path:[{next:H,path:[None]}]}
             ],
             sign:sc
        },
        {
            createTime:xxx,
             next:D,
             minttl:2,
             path: [
                {next:H,path:[None]},
                 {next:F,path:[{next:H,path:[None]}]}
            ],
            sign:sd,
        }
        ],
        sign:sb
      }
    ```
* 从上描述可知，minttl是可以通过遍历path来计算得到的，留着只是快捷计算而已,可以在新加入路由表项的时候，计算一次，传输过程中就不需要传输了

### 路由的更新与合并
#### 路由发现和回应中更新  
上述过程中，路由可能会在以下几个时间点产生，以B发送到H的路由发现，H回应回应中的节点F为例：
1. 当收到C发送的来自B的路由发现请求时，需要更新到B的路由
2. 当收到D发送的来自B的路由发现请求时，需要更新到B的路由
3. 当收到H的路由发现回应时，需要更新到H的路由
4. 当收到来自E的关于A路由发现回应。  
以上描述可以归类成为两种，收到路由请求和路由回应时，都应该更新路由表。

#### 数据传输时更新  
当数据从B传输到H时，假设ALPHA为2，即B->(C,D); C->(E,F), D->(F,G), F->(H), G->(H)；仍旧以F为例，F将收到来自C/D的数据中继请求，此时需要更新路由。我们有两种方案：  
1. 在数据传输的过程中，使用新的createTime,自动构建pathes信息，并且逐级对createtime进行签名
2. 在数据传输过程中，使用新的createTime,并不构建pathes，逐级对createtime进行签名  
使用第一种方案时，更新路由的模式与路由发现/回应过程一致，使用第二种方式时，需要另外考虑路由的更新和验证方案。因此经过考虑，使用第一种方案。    
注意为了在实际的数据传输过程中，为了保证数据在转发过程中不被篡改，因此也需要对数据内容进行签名，因此我们对路由表进行改造，添加一个additional项，然后对（createTime|additional)项进行签名，在路由发现回应时，additional可以是空，在数据传输时,additional是数据的哈希，这个additional在路由发现/回应时会一起传输，路由更新时并不关心additional所代表的实际含义，只是在验证签名时使用。通过这个方式，使数据发送者只需要一次签名。当然，如果数据的发送者和接收者并不关心数据的真实性或者通过另外的方式进行数据真实性验证，也可以不关心additional，通过自己定义的方式进行数据传输。

#### 邻节点失效
当设备与某个邻节点断开时，路由表项中的该项将无法实现数据路由的功能，因此应该删除此表项；但是有可能节点断了以后，过会儿又恢复了，这时候如果路由表项被删除了会导致无法恢复。同时另一方面，当路由表项非常多时，遍历路由表删除或是添加关于某个下一跳节点的路由项是代价昂贵的工作，因此我们按照如下的方案设计：
1. 设置路由表项超时时间为ExpireTime（默认10分钟）
2. 当收到路由请求时，所有的路由表项的nexthops与邻节点表比对，只有还在邻节点表中的，未超时的才有效
3. 当收到数据中继请求时，优先选择在邻节点表中的，未超时的，ttl小的

#### 更新总结  
在上述两种情况下，节点在系统中有一张等待路由更新回应的表pending_route_req,节点在路由更新时，首先更新自己的路由表，然后从路由表中拿出合并后的路由表项，在pendign_route_req中，回应对应的节点。  
事实上，由于路由捷径的存在，如果路由表中已经有表项存在了，收到路由请求时，直接已经回应了，所以pending_route_req就不会产生关于该路由的记录。 


### 路由表项管理
#### 表项合并
由于路由的更新可能存在两种情况，一种是路由发现过程中的更新，另外一种是数据传输过程中的更新，在路由发现过程中，返回
仍旧以F为例，假设B发送了一个到H的路由发现请求后，又发送了一个到E的路由发现请求，通过A/C到达了F，那么F上的路由合并分成两个部分：  
1. 对应更新中的1/2项，同一个createTime，两个不同的分支到达，直接合并
2. 同一个节点对应了两个不同的createTime（B的两个不同的createTime发送的路由请求），每个节点可以预留2个createTime，第三个到达时，使用新的createTime来替换最旧的。


#### 表项失效  
  路由失效有以下两种情况：
  1. 路由表项满的时候，按照LRU失效，这个是通过使用LruCache实现的
  2. 当路由表中的时间超过ExpiredTime时，可以认为这个路由表失效了


### 响应过程 
#### 路由发现处理
当收到路由发现请求时：
1. 如果请求的来源是记录的同一路由发现的目标节点，忽略此节点（rewound）
2. 检查路由表中是否有有效的到达目标地址的路由，如果有，直接取有有效的路由，返回给请求者
3. 如果没有，记录请求者的信息(pending_route_recv)，生成一个新的路由请求，发送给邻节点表中更近的节点
4. 记录这个请求发送的目标地址（pending_route_sent,1中需要使用）
5. 根据来源请求生成路由表项，执行和路由回应同样的处理

#### 路由回应处理
当收到路由回应时：
1. 将路由表项合并到路由表中
2. 查看pending_route_recv是否有请求该路由的项，如果有，回应表项对应的节点

**备注**
上述过程中，每一个节点都会记录向自己发送路由请求的邻节点，然后再中继此路由请求到下一节点，当收到下一节点的路由回应时，根据记录中的请求者进行回应，回应后，并不立刻删除此请求者记录，这个请求者记录具有一个超时时间，当超时时自动删除此记录。只要请求者记录还在超时时间内，就会将新路由信息发送给请求都节点，通过此方式可以实现多次路由的更新。  




#### 路由表
* 路由表的内容  
  中间的节点都需要建立一个路由关系表，路由关系表为$\{dst,next,ttl\}$,对于同一个dst，可以建立多个next路由表
* 路由表的建立  
   1) 每次收到FIND和RESP命令时，都更新路由表{dst,next,ttl} <-- {src,lastHopAddr,orgttl-ttl}
   2) 每次数据发送或回应时，都需要更新路由表

* 路由表的失效   
  路由表的失效时间根据设置的路由表大小而定，同时约定，当两个节点离上一次通信时间超过1小时，再次通信前，应该重发一次路由发现请求以重新建立路由



### 数据传输
#### 数据发送和回应
当路由的通道建立后，就可以发送数据了，
* 发送数据
  发送数据的请求为$\{SEND,dest,\alpha,createTime,additional,pathes:[],data,sign\}$，fd是一个64位的整数，发送方用于鉴定数据是否收到的的标识
* 数据回应
  回应的数据回$\{RECV,dest,\alpha,createTime,additional,pathes,sign\}$，  
其中，
1. dest是目标地址，
2. alpha 是每级的扇出，要求发送者发送几个邻节点，这个未来与计费相关
3. createTime是生成时间，
4. additional是附加的信息，可以是空，也可以是数据的哈希，与createTime一起生成签名
5. pathes是过程路径，注意每一个请求只会有通过过一条路径到达，因此里面是一个简单的PeerId的数组
6. sign是对(createTime|additional)的bls签名
#### 机制说明
1. 路由发现完成后，两个设备间建立了虚拟连接，可以定时发送ping/pong来维持路由
2. 由于在数据层进行发送回应，因此alpha可以设置成1，然后使用超时重发的机制来降低数据发送成本。
3. 无需回应的数据消息，alpha可以从1-3之间选择，不同的alpha代表了不同的可靠性，同时也对应了不同的成本
4. 数据发送的付费问题在《支付费用》中说明


### 攻击及防范
* 放大攻击  
  由于系统中的路由命令会扩大传播，因此恶意节点可以通过发送无效的路由发现请求来占用网络带宽达到破坏网络的目的，为了避免这种攻击，我们可以通过支付费用和黑名单的形式来限制恶意节点攻击行为 

* 支付费用  
    路由通道建立，数据的传输，都需要支付费用，节点信任下一路由节点，向下一节点支付$\alpha^{orgttl}$单位的费用，下一路由节点可能没有转发此路由到更下一层节点，原因可能是没有更新的路由节点了，或者是故意吞没了前一节点的路由费用。 事实上，当路由通道建立后，可能会有大量的数据传输通过此路由通道进行，因此会有更多的收益，因此从经济上来说，转发路由发现协议更合算。  
    费用的支付是通过收据实现的，关于如何实现可合并的收据，见[此处]()


## 算法实现


