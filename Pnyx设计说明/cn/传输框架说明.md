# 传输框架说明
系统中有三种类型的数据传输：
1. 邻节点推送，节点向自身的某个邻节点推送数据
2. P2P传输，节点向指定地址的节点传输数据
3. 全网广播


## 邻节点推送 
### 推/拉算法
考虑节点A、B和C，A向B和C发送某个数据块，经过一段时间的延时后，B转发此数据区给C，但此时C已经收到过A发送的数据了，因此这个数据再发送一次是没有意义的。

我们使用如下的方案，当A需要向B发送数据时，A首先向B发送到一个数据传输请求，这个请求里包含了待发送数据块的哈希值，B收到这个请求后，本地检测哈希对应的数据块是否存在，只有当这个数据块不存在时，才会向A请求此数据，因此包含四个步骤：
1.  A 向 B发送 {pushhash,hash}
2.  B 向 A请求 {pullhash,hash}
3.  A 向 B发送 {pushdata,hash,data}
4.  B 验证 Hash(data) == hash

通过这个方式，使数据不会重复传输


## 点到点传输算法

假设有如下的网络拓扑：

![](route.png)
### 路由发现

#### 发现请求
1. 当B需要发送数据给H时，从邻节点中寻找$\alpha$个离H更近的节点，向这$\alpha$个中继节点发送数据数据中继请求$\{FIND,dest,\alpha,orgttl,ttl,[hash]\}$
2. 在图中，B找到了C/D,当C/D收到此中继请求时 ，将ttl值减去1，然后查找到下一级，在C中找到了E和F，在D中找到了F和G
3. E/F/G将TTL减去1，然后查找到下一级H
4. H收到E/F/G来的请求，发现是自身，通EFG向B发送回应
   
#### 发现回应
1. 发现回应过程中，节点只向上次向自己发送发现请求的节点传播数据
3. 由于节点都是不可信的，因此有可能中间的路由节点会造假，为了防止造假，节点回应的路由信息中，需要有路由目标地址的签名和中间所有中继的签名,在第一个版本中，为了简化开发，要求必须记录从上一节点到目标节点的所有签名，假设我们从B发送了到H的路由请求，然后从H返回此路由回应。
   1. H向E、F、G发送经过签名的路由回应`{createTime:xxx,ttl:0,path:[None],sign:sh}`此处的sh是h对createTime的bls签名；
   2. E/F中记录路由信息，E中
        ```
        {
   
            minttl:1,
            pathes:[{createTime:xxx,next:H,path:None}],
            sign:se
         }
        ```
        和F中：
        ```
        { 
            minttl:1,
            pathes:[{createTime:xxx,next:H,path:None}],
            sign:sf
        }
        ```
        此处的se是e对createTime签名`se'+sh`,由于`bls`签名的线性，这个签名是可验证的。sf同理,此处把自己的签名直接生成加入，免得每次路由查询的时候需要重新生成
   3. E向C发送路由回应
        ```
        {
            createTime:xxx,
            pathes:[{next:H,pathes:None}],
            sign:se
        }
        ```
   4. F向C发送路由回应
    ```
        {
            createTime:xxx,
            path:[{next:H,pathes:None}],
            sign:sf
        }
    ````  
   5. C收到两条路由回应后，形成一条具有两条路径到H的记录,此处的sc同样是bls签名,可以通过E+F+H+C的公钥进行验证
    ```
    {   
        minttl:2,
        nexthops:[
            {next:E,createTime:xxx,pathes:[next:H,path:[None]],sign:se},
            {next:F,createTime:xxx,pathes:[next:H,path:[None]],sign:sf}
            ],
        sign:sc
    }
    ```
    为了简化起见，我们定义总表项数为ALPHA=3，当有第四个createTime的路由需要更新时，删除createTime最早的那个.
   6. C向B回应路由消息
    ```json
    {
        createTime:xxx,
        pathes:[
            {next:E,path:[{next:H,path:[None]}]},
            {next:F,path:[{next:H,path:[None]}]}
            ],
            sign:sc
    }
    ```
   7. D同样向B回应路由信息
   ```json
    {
        createTime:xxx,
        pathes:[
            {next:H,path:[None]},
            {next:F,path:[{next:H,path:[None]}]}
            ],
        sign:sd
    }
   ```
   1. B中形成路由信息
    ```json
      {
        nexthops:[
        {
               createTime:xxx,
            next:C,
             minttl:2,
            path: [
                {next:E,path:[{next:H,path:[None]}]},
                {next:F,path:[{next:H,path:[None]}]}
             ],
             sign:sc
        },
        {
            createTime:xxx,
             next:D,
             minttl:2,
             path: [
                {next:H,path:[None]},
                 {next:F,path:[{next:H,path:[None]}]}
            ],
            sign:sd,
        }
        ],
        sign:sb
      }
    ```
* 从上描述可知，minttl是可以通过遍历path来计算得到的，留着只是快捷计算而已,可以在新加入路由表项的时候，计算一次，传输过程中就不需要传输了

#### 路由的更新与合并
* 路由发现和回应中更新  
上述过程中，路由可能会在以下几个时间点产生，以B发送到H的路由发现，H回应回应中的节点F为例：
1. 当收到C发送的来自B的路由发现请求时，需要更新到B的路由
2. 当收到D发送的来自B的路由发现请求时，需要更新到B的路由
3. 当收到H的路由发现回应时，需要更新到H的路由
4. 当收到来自E的关于A路由发现回应。  
以上描述可以归类成为两种，收到路由请求和路由回应时，都应该更新路由表。
* 数据传输时更新
当

* 合并
仍旧以F为例，假设B发送了一个到H的路由发现请求后，又发送了一个到E的路由发现请求，通过A/C到达了F，那么F上的路由合并分成两个部分：  
1. 对应更新中的1/2项，同一个createTime，两个不同的分支到达，直接合并
2. 同一个节点对应了两个不同的createTime（B的两个不同的createTime发送的路由请求），使用新的createTime来替换旧的

* 路由失效
  路由失效有以下两种情况：
  1. 路由表项满的时候，按照LRU失效，这个是通过使用LruCache实现的
  2. 当路由表中的时间超过ExpiredTime时，可以认为这个路由表失效了


#### 路由回应的传播。
上述过程中，每一个节点都会记录向自己发送路由请求的邻节点，然后再中继此路由请求到下一节点，当收到下一节点的路由回应时，根据记录中的请求者进行回应，回应后，并不立刻删除此请求者记录，这个请求者记录具有一个超时时间，当超时时自动删除此记录。只要请求者记录还在超时时间内，就会将新路由信息发送给请求都节点，通过此方式可以实现多次路由的更新。  
我们设定到某个节点H的路由的超时时间为T，路由条目为R，在节点C上，当路由条目R还在合理的时间范围T内，如果A发送到H的路由请求给C，C可以直接将此路由条目返回。  



#### 路由表
* 路由表的内容  
  中间的节点都需要建立一个路由关系表，路由关系表为$\{dst,next,ttl\}$,对于同一个dst，可以建立多个next路由表
* 路由表的建立  
   1) 每次收到FIND和RESP命令时，都更新路由表{dst,next,ttl} <-- {src,lastHopAddr,orgttl-ttl}
   2) 每次数据发送或回应时，都需要更新路由表

* 路由表的失效   
  路由表的失效时间根据设置的路由表大小而定，同时约定，当两个节点离上一次通信时间超过1小时，再次通信前，应该重发一次路由发现请求以重新建立路由



#### 数据发送和回应
当路由的通道建立后，就可以发送数据了，发送数据的请求为$\{SEND,dest,\alpha,orgttl,ttl,fd,data\}$，回应的数据回$\{RECV,dest,\alpha,orgttl,ttl,fd\}$，fd是一个64位的整数，发送方用于鉴定数据是否收到的的标识

### 攻击及防范
* 放大攻击  
  由于系统中的路由命令会扩大传播，因此恶意节点可以通过发送无效的路由发现请求来占用网络带宽达到破坏网络的目的，为了避免这种攻击，我们可以通过支付费用和黑名单的形式来限制恶意节点攻击行为 

* 支付费用  
    路由通道建立，数据的传输，都需要支付费用，节点信任下一路由节点，向下一节点支付$\alpha^{orgttl}$单位的费用，下一路由节点可能没有转发此路由到更下一层节点，原因可能是没有更新的路由节点了，或者是故意吞没了前一节点的路由费用。 事实上，当路由通道建立后，可能会有大量的数据传输通过此路由通道进行，因此会有更多的收益，因此从经济上来说，转发路由发现协议更合算。  
    费用的支付是通过收据实现的，关于如何实现可合并的收据，见[此处]()



## 全网广播算法
全网广播算法目前是通过gossip协议算法实现的，未来可能会使用推拉算法再优化，对于小数量的数据来说 ，gossip协议效率更高；对于大数据量的数据传输来说，基于推拉算法的广播协议效率更高些。


