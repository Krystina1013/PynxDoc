# 前言
在pnyx中，有大量的需要跨分片处理的交易，例如： 如果帐户Alice向Bob转移一笔资产，需要在Alice帐户中减去，然后在Bob帐户加上相应的值，在分片系统中，帐户alice和分属于两个不同的分片，要实现转帐的效果，需要做到以下的原子性：如果从Alice中扣除了资产，必须保证Bob中肯定能够收到资产；反之，如果从Alice中扣除失败，则肯定不会向Bob增加相应的资产。  
在实现上Alice所在的分片是无法也不应该关心Bob是否收到资产的，否则就会导致分片之间耦合性过强使系统无法工作。在Pnyx中，相应的处理方案是使用跨分片动作Cross-shard-actions，即需要跨分片处理的的动作，在原分片区块处理结束后，作为处理结果存放在区块体里，并且将对应的哈希放在区块头上。其他处理该区块的链，把这个区块看成是输入，然后处理区块体里的Cross-shard-actions。  
![](./imgs/cross-shard.png)  
为了一致性，我们将不同链的区块也作为交易的一种放入到区块中，这样可以享受系统使用substrate的pallet进行各种分开处理的好处。这种交易我们称为区块交易。区块交易的结果原始的跨分片交易的结果会有所不同

## 链外存储
在跨分片中，一种角色的链所生成的区块需要被其他角色的多个链中的节点读取和处理。比如信标链中的区块，会被所有中继链的节点读取和处理；而每一条中继链中的节点，只关心信标链中与自身相关的部分，而与自身不相关的数据最好不需要传输和处理，为了达到这个交易，我们提出了链外存储。  
链外存储是指数据哈希存储到链上（区块中），而数据放在链外，当其他节点有需要时，通过链外存储获取哈希对应的数据。通过这个方案可以降低非必要的数据传输。在上述的信标和中继链的例子中，中继链通过信标区块获得了一组Vec<(ChainRole,Hash）>，然后在这个数组中得到与自身ChainRole一致的哈希，向链外存储请求获取哈希对应的数据`Vec<Hash>`，这样与本身ChainRole不相干的数据，将不会在中继链中传输。  
链外存储的读写分成了两个阶段：向来源节点请求阶段和向P2P存储请求阶段。简单来说，需要依据下面的两个原则：
1. 只要某个节点向链外存储写入了（Hash,Data)对，经过一定的时候，系统中的任何节点都可以通过Hash能够得到相应的数据
2. 如果一个节点在区块中向另外一个节点提供了哈希，在对方节点提出请求时，需要能够将该哈希对应的数据提供给对方。

上述的第一条原则保证了数据的最终一致性，第二条原则保证了快速性。 在使用过程中，如果区块哈希获得的结果还是哈希，需要再次获取一次时，可以直接使用原则1，而不必要通过原则2，因此在实现时，可以提供两种不同的接口或是不同的参数。参考[这里](../3-网络层组件/2-链外存储.md)了解更多的关于链外存储的设计和实现

# 概要说明
跨分片交易过程中的数据设计：  
![](imgs/cross-shard-actions.png)
## 跨分片交易的处理过程
如上图所述，所有的交易本质上是分成两步执行的，
1. 原始交易的结果，原始交易执行的结果可能会产生一个Csaction，原始的交易执行时，如果需要产生Csaction，通过deposit_csaction存储；
2. 对Csaction的进行处理，这个处理将会更新世界树的状态。

与传统的区块交易处理相比，增加了一个Csaction，理论上，Csaction将会被传输到需要对应分片中，由于网络是多层架构的（3层及以上），为了避免Csaction在不相干的链（中继/信标）中传输浪费带宽资源，在区块打包时，需要对存储的csaction进行以下的操作：
1. 是否为要求本分片处理的csaction，如果需要，直接处理后删除
2. 如果是需要其他分片处理的，根据目标分片以及系统中相应的分片指数，把Csaction分层打包，把原始的csaction数据存入到链外存储，然后记录每一层的（目标/哈希值），把最后一层的`Vec<（目标/哈希）>` 打包进入区块

## Csaction生成和处理方式
根据上述的处理过程，Csaction是由交易生成的，比如一个资产转移的交易，可以分解成在本分片上对某个帐号进行资产余额扣除和对可能是另外一个分片帐号的资产余额增加的过程，这个资产余额增加的过程就是csaction。  
为了保证数据一致性，即上述过程中的资产转移过程中，只要交易在原始的分片上被处理，那么对应的csaction早晚会被执行，为了保证这一点，我们使用区块锁定的方式:
1. 中继/分片/信标链区块中需要指示被打包进区块的其他角色链的区块信息（ChainRole,Height和Hash)，
2. 打包其他角色的链的区块信息时，必须按顺序打包而不能跳跃，即中继链打包分片链的区块信息中时，只有当分片的第N个区块已经被打包时，第N+1个区块才可以被打包。

一个角色的链，把其他角色的链的区块看成交易，通过交易池中的设立依赖关系来实现区块的顺序性。

交易生成Csaction时，是由交易的处理代码通过deposit_csaction来实现。deposit_csaction函数有两个参数:target和action。target参数指示该由什么链处理，而action就是处理的过程。此处需要注意的是，
1：由于action是经过编码来实现的，其编码方案与对应的runtime有关，而runtime是根据链层次不同与不同的，因此目前无法跨不同角色，例如分片链目前无法发送相应的csaction让信标链进行处理。 
2：target其实是chain_id（ChainRole类型)，由于系统是弹性分片的，这意味着交易需要根据当前的分片状态来决定target的结果。由于跨分片交易的延迟特性，即分片A区块高度N的csaction可能在中继的分片N+R，分片B的区块高度N+R+B上被处理，而在N+R或是N+R+B区块时，分片指数可能已经与N高度有变化了。csaction对应的AccountID已经不在分片B而是分片B‘中了，此处的B’是由分片B分裂而来。

### 弹性分片时的csaction处理
我们根据中继、信标和分片链不同的角色来来分析，假设在第N个块产生了弹性分片。 为了防止某个节色第N-1个区块处理了其他角色的第N个区块，我们作如下的约定以简化系统的处理方案：任何一个高度为M的区块，只可以处理其他角色中不大于M高度的区块。有了这个前提条件，各个角色的处理过程可以如下所述：

#### 中继链的处理过程
1. 中继链在第N块时，打包了分片A的第N-1个区块BA<sub>N-1</sub>，由于区块中BA<sub>N-1</sub>的CsaResults还是按照分片前的组织的，中继将BA<sub>N-1</sub>中的CsaResults按照分片后的结果，同一个CsaResults项目，即(target,hash)根据target分别按照新的分片指数，生成新的记录。
2. 中继链在区块高度N+1上处理信标链的第N个区块，信标链中的分片方案还是更新前的，推断出本中继处理的所有分片数据，根据新的分片方案，分析所有的分片数据，给相应的分片处理。

#### 信标链处理
1. 信标链在第N块时时，处理中继链的第N-1块区块数据方案，直接根据新的分片方案，把原有的数据一分为二，生成两条记录，由中继链按照自己的方式处理。

#### 分片链处理
分片链在第N+K个区块时，收到中继链的第N个区块的数据方案，解开后，对所有的Csaction进行处理，如果Csaction中的目标不在本分片上，可以直接丢弃。

在上述的处理方案中，在分片切换时，有些Csaction可能会被两个分片处理，上述方案的处理原则是：通过冗余传输保证数据传输的可靠性，通过最终的处理者决定处理的一致性。事实上，对于类似于资产转移这样的交易来说，即使在两个分片上都被加了一次，也不会产生问题，因为后续的其他的节点都是会向正确的分片上查询相应的AccountId的数据。

### csaction的合并与归纳
Csaction在execute_block过程的每个ApplyExtrinsic过程中，由对应的Callable函数通过deposit_csaction来生成。如果不作处理，Csactions需要通过中继链、信标链、目标中继链，目标分片链一系列的转发，而实际上中间的节点并不关心实际的csaction，因此从节约带宽的角度来说，也不应该关心和传输，因此我们需要对csaction再作处理：把同一个target的所有的csaction合并，合并后的结果生成哈希，即Hash=vec![action1,...actionN]，然后得到一组根据不同的target得到的结果Vec<(target,Hash)>，这一组结果，我们称为CsaResults，打包进区块。这个过程在block的on_finalize时，由
proc_csaction来进行处理。



## <span id="proc">跨分片交易生成处理--生成Csaction</span>
如上所述，跨分片交易分成两种，原始交易和区块交易，在目前的实现中，原始交易只有在分片区块上被处理，而区块交易在三种链的角色上都会被处理。既然是交易，可以被设计成由pallet处理，因此此处只是对原始交易需要得到跨分片结果的部分进行描述，重点描述区块交易的处理方案
### 原始交易处理
原始交易通过deposit_csaction进行处理
### 区块交易处理
#### 分片链处理区块交易
分片链总是处理来自于对应中继链的处理交易：
1. 从中继的downstream中可以得到给自身的(ChaiRole,Hash)对
2. 从链外存储中获取Hash对应的Vec<Csaction>
3. 通过deposit_csaction存储Csaction

#### 中继链处理区块交易
中继链需要处理来自于下属分片的区块交易和信标链的区块交易
##### 分片链区块交易处理
1. 分片区块中的upstream中的每一条，通过deposit_csaction插入到存储中

##### 信标链区块交易
1. 从信标区块中的downstream得到需要自己处理的(ChainRole,Hash)对
2. 根据哈希从链外存储中获取对应的`Vec<Hash>`
3. 把数组中的每一个哈希，生成一个新的csaction，通过deposit_csaction存储


#### 信标链处理区块交易
信标链处理中继的区块交易
1. 读取每个中继分片中的upstream中的每一条，生成csaction存储


## 处理csaction
生成csaction都是有一个target，根据这个target进行不同的处理：
1. 如果target是自身，那么就调用相应的Csaction.execute
2. 如果target不是自身，那么就根据不同的target来合并同一个target的Csactions，
	1. 同一组csaction生成哈希，数据存入到链外存储
	2. 记录(target,hash)
3. 根据不同的target生成CsaResults

# 详细设计



## 实现说明 
根据目前的substrate的通用框架，实现分成两个部分，
1. 与区块逻辑相关的部分，应该放在primitive/runtime里实现
2. 与实际的实现的链相关的部分定义，应该放到自身的的实例化frame/system化的过程中
3. 实现应该由frame/Executive进行

Pnyx中跨分片交易有两个部分构成：
1. 交易执行项，需要跨分片处理的交易内容
2. 交易存储项：出块者将所有的交易执行项按需进行分组，分组后的结果形成哈希，然后将多组哈希组合，形成交易的存储项

根据上述描述，我们可以得出几个结论：
1。 交易的执行项并不在区块中存储，而是在区块外存储（可能是链外存储）
2。 存储项和执行项是逻辑的区分，同一项在不同的链中将担任的不同角色。例如分片链的交易存储项是中继链的交易执行项。因此在实现中，我们统一称为跨分片交易项，简称交易项

### 流程
以一个交易为例，描述该交易在分片系统中的处理过程，这个处理过程中指持有该交易的数据结构的转换，转换后的数据在跨分片过程中被处理的过程。
我们首先定义某一个余额型的交易跨分片处理的对象元组R:(accountId,value)
1. 分片的处理：
   1. 在原始分片里，按照目标中继分组，每个分组里就是一个向量`Vec<(accountId,value)>`，这个向量生成哈希`HR`，得到与目标中继对应的一个元组`(RelayId,HR)`，
   2. 分片将`HR`对应的实际数据`Vec<(accountId,value)>`存入到链外存储系统
   3. 按照目标中继分组将得到多个元组，记录该向量到区块`Vec<RelayId,HR>`
2. 中继的处理：
   1. 中继将收到多个区块，得到多个区块中的向量组`Vec<RelayId,HR1>`..`Vec<RelayId,HRN>`
   2. 中继根据向量组中的RelayId重新合并，得到目标是某个中继的一组{HR1,...,HRN}，然后生成该RelayId的新的哈希HJ=Hash(HR1,...,HRN)
   3. 中继在区块中打包Vec<(RelayId,HJ)>，然后广播
3. 信标的处理
   1. 信标将收到多个中继的区块，得到多个区块中的向量组`Vec<RelayId,HJ1>`..`Vec<RelayId,HJN>`
   2. 信标根据收到的向量组中的RelayId重新合并，得到目标是某个中继的一组{HJ1,...,HJN}，然后生成针对该RelayId的新的哈希HK=（HJ1,...,HJN)
   3. 信标在区块中打包Vec<(Relay,HK)>,然后广播
4. 目标中继的处理
   1. 目标中继(RelayId)收到信标区块，从区块中得到`Vec<(Relay,HK)>`，取出`HK`
   2. 接收节点向来源节点请求与自身的RelayId对应的HK数据，得到一组`{HJ1,...,HJN}`
   3. 接收节点向链外存储请求，得到每个HJ对应数据`{HR1,....,HRN}`
   4. 接收节点向链外存储请求，得到每个HR对应的数据`Vec<(accountId,value)>`
   5. 接收数据根据`Vec<(accountId,value)>`中accountId和当前的分片指数情况，重新按照分片处理，得到根据分片的一组向量`Vec<(accountId,value)>`,然后根据每个分片的向量生成哈希`HL`
   6. 这些HL形成向量`Vec<ShardId,HL>`,打包到区块中继内广播
5. 目标分片的处理
   1. 目标分片收到中继区块，从中继区块中得到`Vec<ShardId,HL>`
   2. 分片区块节点向来源的中继节点请求与自身ShardId对应的HL对应的向量数据`Vec<(accountId,value)>`
   3. 分片区块节点根据`Vec<(accountId,value)>`更新自身内帐户的余额信息
#### 链内处理
链内的处理过程分成以下几个阶段
```mermaid
  交易处理  --> CsaActionItem或者CsaResultItem
  
  对CsaActionItem处理 --> 分成两个部分：
  1. 本地处理的，要么更新了状态树，要么生成下行的分组结果
  2. 非本地处理的，生成被根据目标分组后的结果
```  
* 这里的原始交易可能是一个资产转移交易，也有可能是一个被纳入区块的其他链的区块
* 这里的第一步生成的CsaActionItem就是简单的需要跨分片交易处理的内容，而这个分片可能是自己
  * 比如说一个资产转移交易，总是会生成一个在原始链上扣除资产的动作和一个增加资产的动作
  * 为了统一起见，这个增加资产动作总是一个CsaActionItem
  * 系统会自动对所有的CsaActionItem进行一次处理，如果是自身链的，就在本地处理完毕，
  * 如果不是自身这个链，就会依据需要处理的中继链，重新生成一个CsaActionItem
  * 这个CsaActionItem是可以根据目标重新处理的，所以为了区分，我们命名它为PostCsaActionItem

因此CsaAction的存储具有两个部分：
1. 第一部分就是存储原始的CsaActionItem
2. 第二部分用于存储处理过的PostCsaActionItem

#### 弹性分片处理（目前只考虑扩展）
   当系统支持弹性分片时，原始的分片根据分片指数对交易进行分组，当这些分组后的交易被目标链处理时，分片指数可能已经变化了，因此原来的分组方案可能与新的不一致了，这时需要做特殊的处理：  
   下面的讨论我们做了如下的假设：
   1. 链中的区块只打包对应的链中高度比自己低的区块（如中继链N+1高度只打包分片链中不大于N+1的区块）
   2. 在区块高度为N+1时，需要进行弹性分片
   3. 以分片和中继为例，其余的类推，
   假设分片高度为N的区块被高度为N+1的中继区块进行处理，中继编号为A，分片编号为AB，这时候有两种情况：
   1. 假设是中继扩展一倍了，即分片指数从（R,S）升级成(R+1,S)
      1. 中继A分裂成A,2<sup>R</sup>+A
      2. 分片AB分裂成AB和2<sup>R</sup>+AB两个
      3. 在区块高度为N的时候，分片还没有分裂
      4. 在区块高度是N+1的时候，中继链A和2<sup>R</sup>+A都打包分片高度N的数据
      5. 由于高度已经是N+1了，因此中继链A和2<sup>R</sup>+A根据新的分片指数决定哪些数据需要自己处理，不需要处理的数据直接丢弃（应该被对端的分片处理了）
      6. 中继2<sup>R</sup>+A需要在所有管理分片中的第N个区块以及信标链的第N区块全部被处理后，才离开中继R所在的网络
   2. 或者是中继内的分片扩展一倍了，即分片指数从（R,S）升级成(R,S+1)
      1. 中继A不变
      2. 分片AB分裂成了AB和A(2<sup>S</sup>+B)
      3. 中继处理第N高度的AB
      4. 中继处理第N+1高度的AB和A(2<sup>S</sup>+B)
      5. A(2<sup>S</sup>+B)在N区块最终确定化后，退出AB网络

### 数据结构
#### CsaActionItem

#### CsaResultItem
CsaResultItem是交易的执行项，即上述的Vec<Target,Data>，对于不同的交易类型，其Target和Data可能不同：
1. Target 
   Target无非三种：目标是某个分片、某个中继或是信标链，因此我们可以使用一个Enum来表示Target，这个正好是对于ChaiId
2. Data
   Data与实际的操作相关，目前我们已知的有：
   1. 增加资产
   2. 锁定写数据
   3. 写锁定数据回应
   4. 解锁写
   5. 读锁定数据
   6. 读锁定回应
   在上述6种之外，我们还有一种特殊的Data,就是经过处理后的记录，即针对对某个目标的一组结果形成的哈希，我们称为GroupedItems
   7. GroupedItems
   此处我们可以得知，未来Data是基于应用层的，与应用有关的数据结构，为了更加通用化，我们定义一个Trait来管理此类型


#### CSAResults
对于中继链，其跨分片交易的数据被分成了两部分，提供给Beacon的部分和提供自身所管理的Shard链部分。因此我们需要根据不同的类型定义不同的CsaReuslts.

## Frame/System/lib改动

数据项

      ///记录了所有的跨分片交易，在每次结束的时候，需要被清除
		CsaActionItems   get(fn csa_action_item): Vec<<<T as Trait>::CsaResults as CsaResultsT>::ResultItem>;


		///（临时中间的）重新分组后的跨分片交易，在结束的时候，原始数据存入链外存储,哈希放入区块
		GroupedActionItems   get(fn group_action_item): Vec<<<T as Trait>::CsaResults as CsaResultsT>::ResultItem>;
      
		///跨分片交易最后生成的哈希
		CsaRoot			get(fn csa_root):T::Hash;

		///链ID号
		ChainId			get(fn chain_id):<<T as Trait>::Header as traits::Header>::ChainId;

		///分片指数，分片指数是被DigestItem所更新的
		ShardExp		get(fn shard_exp):u8;

# Csa跨分片执行过程设计      
我们期望，跨分片数据的打包分解处理和实际的执行过程是分离的，具体来说，我们希望跨分片的数据打包、分解、重新处理是在系统层级处理，而实际的执行跨分片操作结果的动作是在pallet层级进行处理。

分离后的好处是显而易见的：第统层级无需也并不关心实际的跨分片动作；在扩展跨分片操作时，系统层级无需任何修改。  
我们按以下的方式来实现这个执行过程，经过分析，我们此设计方案具有两个缺点：
1. 数据量约增长2%
2. 总的跨分片关系的执行类型不能超过255个

我们认为这两个缺陷是可以接受的。

## 数据结构定义
### 每一个csa项的执行器的特征
```rust 
pub trait ActionExecutor {
	fn run(target:ChainId,val:Vec<u8>);
}
```

### csa 动作项的分发器
解开编码后的的动作项，并且根据解码的结果，调用相应的执行器进行执行
```rust
pub trait CsaDispatcher: Codec + MaybeMallocSizeOf + Clone  + 'static
{
	type TargetType:PartialEq + Eq + std::hash::Hash + Copy ;
	fn execute(&self,target:Self::TargetType,data:Vec<u8>);
}
```
**以上两个需要在最终实现的时候实例化**

### 跨分片交易的记录的特征
这个是每个跨分片交易记录都是一条
```rust
pub trait CsaResultItem:  Debug + MaybeSerializeDeserialize + Codec + MaybeMallocSizeOf + Clone  + 'static  {

	type TargetType:PartialEq + Eq + std::hash::Hash + Copy ;
	type DataType:PartialEq + Eq +Clone + CsaDispatcher<TargetType=Self::TargetType> + Codec;
	//创建
	fn new(target:Self::TargetType,data:Self::DataType)->Self;
	//返回目标
	fn get_target(&self)->&Self::TargetType;
	//返回数据
	fn get_data(&self) -> Self::DataType;
}
```


### 存储一组跨分片交易的记录
这个是按组在区块中存储的

```rust
pub trait CsaResults:Member  + Debug + MaybeSerializeDeserialize
 + MaybeDisplay   + Codec + MaybeMallocSizeOf + 'static
{
	/// Header hash type
	type Hash: Member + MaybeSerializeDeserialize + Debug + sp_std::hash::Hash + Ord
	+ Copy + MaybeDisplay + Default + SimpleBitOps + Codec + AsRef<[u8]>
	+ AsMut<[u8]> + MaybeMallocSizeOf;
	/// Hashing algorithm
	type Hashing: Hash<Output = Self::Hash>;
	///跨分片交易数据类型
	type ResultItem:Debug + MaybeSerializeDeserialize + Encode + Decode + EncodeLike + MaybeMallocSizeOf + CsaResultItem + Clone  ;
...
```

## 用户实现示例
### 多个`ActionExecutor`实现
```rust
#[cfg_attr(feature = "std", derive(Serialize, Deserialize, parity_util_mem::MallocSizeOf))]
#[derive(PartialEq, Eq, Clone, Encode,Decode,Debug,PartialOrd,Ord)]
pub struct HashAction(H256);

impl ActionExecutor for HashAction{
	fn run(target:ChainId,val:Vec<u8>){
		if val.len() == 32{
			println!("ok");
		}else{
			println!("oops!");
		}
	}
}
#[cfg_attr(feature = "std", derive(Serialize, Deserialize, parity_util_mem::MallocSizeOf))]
#[derive(PartialEq, Eq, Clone,Encode,Decode, Debug,PartialOrd,Ord)]
pub struct BalanceAction(u128);
impl ActionExecutor for BalanceAction{
	fn run(target:ChainId,val:Vec<u8>){
		if val.len() == 16{
			println!("ok");
		}else{
			println!("oops!");
		}
	}
}
```

实现之后，组成CsaDispatcher，注意，CsaDispatcher是一个枚举类型
### CsaDispatcher实现
枚举定义

```rust
#[cfg_attr(feature = "std", derive(Serialize, Deserialize, parity_util_mem::MallocSizeOf))]
#[derive(PartialEq, Eq, Clone,Encode,Decode, Debug,PartialOrd,Ord)]
pub enum Actions{
	None,
	Balance(BalanceAction),
	Hash(HashAction),
}
```
特征实现：
```rust
impl traits::CsaDispatcher for Actions {
	type TargetType = ChainId;
	fn execute(&self,target:Self::TargetType,data:Vec<u8>){
		use Actions::*;
		match &*self{
			Balance(balance)=>{
				println!("balance")
			},
			Hash(action) => {
				println!("Hash")
			}
			None =>{
				println!("nonone")
			}
		}
	}

}
```

### 定义CsaResultItem

结构把上述的Actions定义成了第二部分（执行器）
```rust
#[derive(PartialEq, Eq, Clone,Encode,Decode, Debug,PartialOrd,Ord)]
#[cfg_attr(feature = "std", derive(Serialize, Deserialize, parity_util_mem::MallocSizeOf))]
pub struct CsaResultsItem {
	target: ChainId,
	action: Actions,
}

impl Default for CsaResultsItem {
	fn default()->Self {
		CsaResultsItem {
			target: ChainId::ChainBeacon,
			action: Actions::None,
		}
	}
}

#[cfg(feature = "std")]
impl std::fmt::Display for CsaResultsItem{
	fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
		write!(fmt, "no no no")
	}
}
```
实现特征，注意TargetType和DataType的定义  
```rust
impl CsaResultItemT for CsaResultsItem{

	type TargetType = ChainId;
	type DataType = Actions;

	//创建
	fn new(target:Self::TargetType,action:Self::DataType)->Self{
		CsaResultsItem {
			target,
			action,
		}
	}
	//返回目标
	fn get_target(&self)->&Self::TargetType{
		&self.target
	}
	//返回数据
	fn get_data(&self) -> Self::DataType{
		self.action.clone()
	}
}
```

### 在区块中定义CsaDispatcher关联类型
定义了Results就定义了CsaDispatcher类型，路径
1. 定义CsaResults 需要（Hashing,Hash,ResultItem)三个类型
2. 定义Resultitem需要TargetType,DataType两个类型
3. 定义DataType需要CsaDispatcher类型

## 系统层实现
系统层实现在FRAME/system中实现


## 未来升级
未来通过宏系统自动实现CsaDispatcher，从而避免需要针对每一条进行手工处理