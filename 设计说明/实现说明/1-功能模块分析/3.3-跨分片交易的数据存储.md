# 前言
pnyx使用了全分片系统，因此不同的节点所对应的数据不同，而弹性分片将导致一个节点在不同的区块时，属于不同的分片，下图是分片弹性扩展的过程：
![](imgs/shard-scaleout.png)
当系统中的分片从P扩展到2P时，原来编号为N的分片将分成两个N和P+N。可以看出，有一部分节点还在N中，另外有一部分节点移动到P+N中去。节点应该在哪个分片中，与它们的地址有关， 节点所在分片的计算方式是：  
`chain_id = node_addr[:-4] & chain_shard_exp`，  
其中: 
* `node_addr[:-4]`表示节点地址的后4个字节
* `chain_shard_exp`是分片数，其值由ShardExponent中的relay和shard决定，算法为chain_shard_exp = 2 <sup> relay+shard</sup>-1

以上示例的链，我们称为在区块N高度上进行了分片扩展, 对于过去的区块，可能已经发生过多次的分片扩展；对于未来的扩展，可能需要在某个区块上进行分片扩展。因此我们需要一个关于分片扩展的历史记录，从而得知当前区块的实际分片情况以及节点所在分片的位置。同样，不同的角色所在的分片号不同，比如说中继链节点总是在中继分片中，而信标链永远只有一个。因此，要得到节点当前所在的分片，我们需要以下几个信息（A）：
* 节点的角色
* 分片的过去和未来记录信息
* 当前链的高度
* 当前节点的地址

## 数据同步考虑
弹性分片是由信标链发起的，因此信标链总是记录了弹性分片的历史记录，由于信标链总是只有一条，是固定不变的，因此节点在同步的时候，可以考虑先从信标链上取得分片信息，然后再根据此分片信息，获取自身所在的分片。详细的过程说明，请参考[快速同步]()

# 分片信息的设计方案

由于所处分片值需要计算获得，Client在创建或是验证区块时，需要根据A中的4个信息获得区块的分片信息，当前链的高度和分片的信息在链上（Beacon或是本链）区取，而节点的角色和节点的地址需要通过配置传入。因此我们对于三种不同的链，需要创建三个ServiceBuilder，把相应的角色和地址传入。

在非分片系统中，只有在出块或是生成交易时，才需要将使用节点的地址，而在分片系统中，节点需要一直使用地址信息来确定自身所在的链信息，因此，最简单的方法是将地址信息也存储到数据中元数据信息中去。

信标链生成了分片指数信息，中继链节点处理分片指数信息，然后同样广播到分片链中，分片指数信息的处理有两种：链下处理和链上处理。链下处理是指数据节点里处理，其结果并不需要通过共识认证，每个节点处理后，更新自身的数据。链上处理是指处理的结果放入到世界树里，这样就可以经过共识处理并且被哈希锁定。  

无论是链上还是链下，分片指数信息的历史记录需要被保存，这样节点才能够通过此记录回溯自身在不同的区块高度时，所处的分片情况。由于[快速同步]()功能的存在，节点不是从最创世区块开始对所有的区块进行重放，而是从最近的快照开始，对此快照后续的区块进行重放。由此可见节点同步的数据是从某快照开始的，而快照就是一个世界状态树，世界状态树是由链上处理生成的，因此分片指数信息必须被链上处理。同时由于分片指数信息是需要被链下频繁使用的，因此我们也需要在链下快速访问，链下访问世界树状态并不是一个特别容易或是合适的行为，因此我们可以在链下为链上的分片指数做一个镜像。我们可以考虑多个方案来实现，第一种方案具体来说有两点：

1. 在同步快照的时候，需要将链状态树中的信息复制一份给链下
2. 链下同样处理DigestItem(ShardExp)中的信息，这样在收到DigestItem(ShardExp)的信息时，更新分片指数

这个方案有个问题：分片信息在链上和链下都保存，都有修改，这从设计上是有问题不可能接受的，两个数据的一致性无法得到保证。因此我们可以考虑方案二：
1. 分片指数信息数据总是从链下向链下复制
2. 链上把分片指数信息复制到链下两个时间点，一个是读取快照的时候，另外一个是处理DigestItem(ShardExp)
3. 链下永远只读取而不修改分片指数信息

* 在这个方案里，链下需要给链上提供一个更新分片指数信息的接口。

## 分片信息存储