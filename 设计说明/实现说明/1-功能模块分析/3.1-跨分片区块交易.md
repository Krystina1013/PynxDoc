# 说明
本文档描述不同的角色对区块进行的处理：

# 区块的转发
由设计可知，在信标/中继和分片几个不同的角色间，区块头需要进行转发处理。即：
1. 信标链的区块头，需要转发到所有的中继链中
2. 中继链的区块头，需要转发到信标链和分片链中
3. 分片链的区块头，需要转发到对应的中继链中。


区块头转发到另外一个角色中，我们有几种方法，我们以信标链处理中继链的区块头为例：
* 第一种方法是在链下，把中继的区块消息广播到到信标链网络分组里，信标链出块节点在打包时，把相应的中继区块的编号/高度/哈希打包进区块里，然后处理这些被打包的区块后得到结果。
* 第二种方法类似于OffWorker，该worker收到中继链的区域块头后，把这个区块头改造成Applyable的交易，然后放入交易池，由交易池进行去重和中继转发等管理。然后区块创建者将交易池中的交易打包到区块中。

第二种方法将需要处理的区块与普通交易一样处理，这样免去了做特殊化处理的过程，因此在本方案中，采用第二种方案。为了行文方便，我们命名这些交易为"区块交易"。

# 交易设计
我们使用交易的依赖tags来管理交易的顺序，每个区块交易需要有两个tag:
* 上一区块的高度
* 本区块的哈希  
  
每个区块提供两个tag:
* 本区块的高度
* 本区块所最终确定化的区块的哈希

通过上述的方案，我们可以实现：任何区块交易进入就绪队列，必须满足以下两个条件：
1. 前一区块已经被打包进入区块（由前一区块提供高度）
2. 本区块已经被最终确定化了（由后一区块提供最终确定化的哈希）

通过此方式首先保证了区块被打包的连续性（不可能被跳过），也防止了非最终确定区块可能导致的回滚雪崩。不过需要注意的是，假设在同一个区块中打包了某个链的连续两个区块交易，区块体中并不保证这两个区块交易的先后次序。而事实上，区块交易总是产生中间结果-对状态的更新，而这些状态的更新在一个区块内执行并且结果会被合并，所以要求区块的顺序处理是没有意义的。  
在某些情况，用户的动作执行可能是需要顺序的，比如说动作A执行后，B才可以执行，这个尤其在智能合约中经常需要，因此我们需要对智能合约的执行做如下的约定：
1. 一个智能合约的函数，如果不访问跨分片的变量，总是在一个区块内执行完成；
2. 如果需要访问跨分片变量，需要通过读写锁原语，读写锁原语采用回调和闭包的形式，读写锁执行前后的代码不在一个区块内执行。

# 区块交易实现
有一个专门的模块来实现对区块交易处理，这里面包括两点：  
1. 收到相关的区块时，会转换成交易后导入交易池
2. 收到其他节点广播的区块交易后，验证该交易的真实性，然后放入到交易池  
与原有的设计方案一致，如果交易池中该交易不重复，是新增的，交易池会产生一个交易导入成功的事件，在外部的线程里监听这个事件，实现广播的传播。

## 区块交易的验证
区块交易的验证是指验证该交易是否为已经最终确定化了，而最终确定化的标识就是区块或是区块的任何子区块的权重超过51%。由于验证权重是否超过51%需要确认投票代理的真实性，因此互相有关联的两个链，需要得到对方的委员会成员信息。
