# 说明
本文档描述不同的角色对区块进行的处理：

# 区块的转发
由设计可知，在信标/中继和分片几个不同的角色间，区块头需要进行转发处理。即：
1. 信标链的区块头，需要转发到所有的中继链中
2. 中继链的区块头，需要转发到信标链和分片链中
3. 分片链的区块头，需要转发到对应的中继链中。


区块头转发到另外一个角色中，我们有几种方法，我们以信标链处理中继链的区块头为例：
* 第一种方法是在链下，把中继的区块消息广播到到信标链网络分组里，信标链出块节点在打包时，把相应的中继区块的编号/高度/哈希打包进区块里，然后处理这些被打包的区块后得到结果。
* 第二种方法类似于OffWorker，该worker收到中继链的区域块头后，把这个区块头改造成Applyable的交易，然后放入交易池，由交易池进行去重和中继转发等管理。然后区块创建者将交易池中的交易打包到区块中。

第二种方法将需要处理的区块与普通交易一样处理，这样免去了做特殊化处理的过程，因此在本方案中，采用第二种方案。为了行文方便，我们命名这些交易为"区块交易"。

# 交易设计
我们使用交易的依赖tags来管理交易的顺序，每个区块交易需要有两个tag:
* 上一区块的高度
* 本区块的哈希  
  
每个区块提供两个tag:
* 本区块的高度
* 本区块所最终确定化的区块的哈希

通过上述的方案，我们可以实现：任何区块交易进入就绪队列，必须满足以下两个条件：
1. 前一区块已经被打包进入区块（由前一区块提供高度）
2. 本区块已经被最终确定化了（由后一区块提供最终确定化的哈希）

通过此方式首先保证了区块被打包的连续性（不可能被跳过），也防止了非最终确定区块可能导致的回滚雪崩。不过需要注意的是，假设在同一个区块中打包了某个链的连续两个区块交易，区块体中并不保证这两个区块交易的先后次序。而事实上，区块交易总是产生中间结果-对状态的更新，而这些状态的更新在一个区块内执行并且结果会被合并，所以要求区块的顺序处理是没有意义的。  
在某些情况，用户的动作执行可能是需要顺序的，比如说动作A执行后，B才可以执行，这个尤其在智能合约中经常需要，因此我们需要对智能合约的执行做如下的约定：
1. 一个智能合约的函数，如果不访问跨分片的变量，总是在一个区块内执行完成；
2. 如果需要访问跨分片变量，需要通过读写锁原语，读写锁原语采用回调和闭包的形式，读写锁执行前后的代码不在一个区块内执行。

# 区块交易实现
有一个专门的模块来实现对区块交易处理，这里面包括两点：  
1. 收到相关的区块时，会转换成交易后导入交易池
2. 收到其他节点广播的区块交易后，验证该交易的真实性，然后放入到交易池  
与原有的设计方案一致，如果交易池中该交易不重复，是新增的，交易池会产生一个交易导入成功的事件，在外部的线程里监听这个事件，实现广播的传播。


## 区块交易的验证

参考 [实现原则及路线图](../0-设计思考/实现原则及路线图.md)， 我们需要对以区块为交易的过程处理以下的工作：  
1. 在收到区块的时候，对区块进行处理
   1. 验证是否为已经最终确定化的
   2. 收集需要用的p2p数据
2. 处理完成的区块，把这个区块作为交易放入到交易池
   1. 需要能够生成交易（此处应该是unsigned transaction)
   2. 需要在网络层修改以使交易能够在本机的不同的节点类型中传递
3. 交易池处理
   1. 不同的类型具有不同的交易池（最多3个分片、中继和信标）
   2. 把区块作为交易放到交易池中，交易需要传播，该交易是非独立交易，其他节点收到此交易时，可能需要向来源节点请求相应的依赖
      1. 如果相应的依赖不满足，就不会把这个交易放到ready中去，也就不会被打包
      2. 如果新到达区块，区块中某些交易的依赖未满足，就无法进行验证，需要调用Offchain来满足相应的依赖

* 区块交易的验证是指验证该交易是否为已经最终确定化了，而最终确定化的标识就是区块或是区块的任何子区块的权重超过51%。由于验证权重是否超过51%需要确认投票代理的真实性，因此互相有关联的两个链，需要得到对方的委员会成员信息。

在原有的系统中，交易是独立的， 即交易本身的消息就具有有关所有此交易的描述，一个典型的例子就是资产转移，只需要源帐户、目标帐户、值和签名，因此验证的过程非常简单：1）签名是否有效，2）帐户中余额是否足够。而当我们把一个类型链的区块作为另外一个链的交易输入时，这个交易内只含有区块的基本信息（哈希、高度、链信息等），因此验证交易的正确性就成了一件比较麻烦的事。  
交易在三个地方可能会需要被验证：
1. 节点收到了一个相关链区块，对该区块进行验证，验证完成后生成一条“区块交易”，放入到交易池时，或者：
2. 节点的交易池收到另外一个节点传播过程来的本地交易池中没有的交易时，或者
3. 节点收到了本链内的一个区块，该区块内的交易本地的交易池中没有时。

对于1产生的交易，验证交易所需的数据，本地肯定已经存在了；而2和3的交易中，本地数据有可能不存在。  
而验证的过程1和3都可以在Verifier.Verify中进行，2需要在交易池纳入交易时处理。
而
1. Verifier.Verify是可以由应用或是共识自己实现的

## import_block被调用的过程
 import是在收到`SwarmEvent::Behaviour(BehaviourOut::BlockImport(origin, blocks)`时被调用，从此事件到import过程如下：

1. client/network/src/service.rs中，收到`SwarmEvent::Behaviour(BehaviourOut::BlockImport(origin, blocks)`，调用this.import_queue.import_blocks(origin, blocks)
2. BasicQueue的import_blocks发送响应-ToWorkerMsg::ImportBlocks
3. BlockImportWorker（响应-ToWorkerMsg::ImportBlocks）->import_a_batch_of_blocks->import_many_blocks --> import_single_block  -> check_block

事件`SwarmEvent::Behaviour(BehaviourOut::BlockImport(origin, blocks)`在两种情况下产生：
1. 在同步过程中，`on_block_response`函数里：`self.sync.on_block_data`，然后`match self.sync.on_block_data`时，处理`sync::OnBlockData::Import`，生成`CustomMessageOutcome::BlockImport(origin, blocks)`
2. 在区块通告中，`on_block_announce`过程中，使用了 `match self.sync.on_block_data`,获得相应的区块，然后然后与上一过程一致的方案生成`CustomMessageOutcome::BlockImport(origin, blocks)`