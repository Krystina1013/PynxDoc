# 说明
本文档描述在如果Substrate上实现Pnyx算法的，实现高性能的分片区块链系统。Pnyx算法的描述和证明见[《Pnyx算法说明》](./../../Pnyx算法说明/cn/委员会竞选.md)。

本系列设计说明书将会按模块描述实现：
1. 创世区块及启动
2. 分片链及弹性扩展算法
3. 委员会选举算法
4. 区块设计
5. 出块算法
6. 跨分片合约

本文将会对以上所有的模块进行概要设计，然后每一个模块单独会有一个详细设计模块。此处的概要设计和详细都是依据在substrate上如何实现而编写的。  
# 创世区块及启动
在substerate中，创世区块的配置是通过genesis.config来实现，genesis.config是一个开放式的可以自由定义的JSON格式文件。每个pallet都可以自由读取genesis.config中的属性。在Pnyx中，需要配置以下的几个属性：
1. 可信节点： 是在启动的时候，可以默认的可信节点，可信节点默认是委员会成员
2. 委员会成员最小和最大个数： 每轮EPOC中可以选举出来的委员会成员数量
3. 代理成员数量：每个出块周期中，可以参与投票的委员会节点数量
4. 弹性分片阈值：当每个分片内的节点数超过这个阈值时，分片将扩展一倍，分片如何扩展的方式在弹性分片算法中讨论，注意一旦分片扩展，扩展后分片内节点的数量是扩展前的一半，因此这个弹性分片的阈值建立至少是委员会成员最小数量3倍到4倍。如果委员会成员数量大，比如1K以上个，可以选3倍；如果比较少，比如199个，建议选4倍。
5. 节点参与竞选最小能力阈值：这个值用于防止女巫攻击，节点加入网络后，需要达到一定的要求后，才可以参与竞选和出块。这个要求是一个全网可计算的能力值，在测试网络中，是抵押token的数量，在正式网络中，将会是存储容量。
6. EPOCH中区块数：每个EPOCH中包含的区块数，默认为1000。
7. 可信节点权力移交阈值：在什么情况下，开始委员会成员选举，选举成功后，可信节点退出。 
8. 预置帐户余额：多个预置的帐户，预置帐户中的余额是多少。 


有了以上的配置，设计启动方案时，我们还需要考虑以下几个问题：
1. 新加入的节点，需要一定的抵押才有出块的权力，网络还没有开始挖矿，抵押物从何而来？
2. 委员会成员一开始由可信节点担任，后续由各个节点参与选举后生成，从可信节点向选举转移的条件是什么？如果转移的早了，可能委员会选举会不成功（节点数达不到要求），如果转移的晚了，对其他的节点又不公平。


针对第1条，在测试网络中，我们提供一个facuet(水龙头)，每个节点每天都可以向这个水龙头申请一个币。这个水龙头后面有一个预置有余额的帐户。在正式网络中，用户可以购买预发行的代币。
针对第2条，我们简单地进行委员会选举，如果选举成功（委员会数量超过最小阈值要求），下一个Epoch就以选举的结果为准，如果没有达到，还是继续可信节点的方案。

注意，创世的时候，并没有要求可信节点达到最小委员会阈值，这个是为了创世更方便。在正式链中，一旦权力转移给委员会，创世节点就可以退出网络了。

因此，创世过程如下：
1. 配置genesis.config文件
2. 在相应的pallet中，根据genesis.config配置文件读取可信节点作为委员会成员
3. 链的状态为创世状态，委员会成员和代理成员的数量为genesis.config中配置的可信节点数量，除此之外所有的节点按照普通的逻辑进行出块计算和验证。
4. 创世状态下，节点同样进行委员会竞选，如果某个Epoch委员会竞选满足要求时，链进行非创世状态。
5. 链进入非创世状态后，委员会成员和代理成员的数量为genesis.config中配置的节点委员会成员和代理成员数量

创世的时候，同时建立了信标、中继和分片三个链，这三个链使用的都是genesis.config中的可信节点。  
由于链分成了三种类型：分片链、中继链和信标链，由于各种链对区块生成的逻辑和交易处理有相同之处，也有不同之处理因此需要创建多种不同的pallet。下面的每一项概要设计中，会简要描述各个模块的所需要的pallet设计。
# 分片链及弹性扩展算法
由于在Pnyx中，节点需要持续提供服务，在正式链上，是要求间隔性地提供存储证明明；在正式链前，是通过参与委员会竞选。无论何种方式，都可以得到当前仍旧在提供服务的节点信息。这个节点信息可以用于作为分片扩展的依据。
分片算法是贯穿Core和Frame中的一个模块，它包括两个部分：
1. 在Core中计算各个链的节点数，如果节点数达到扩展的标准，在区块头中添加扩展的标志
2. 中继链上所有的节点根据分片的区块头中的标识，决定中继分片的数量以及自身所属的中继分片
3. 分片链上所有的节点根据中继分片中区块头的标识，决定分片的数量以及自身所属的分片
## <span id="shard_selection">分片选择</span>
每个节点都可以自主选择进入分片链、中继链或是信标链，系统中信标链只有一条，而分片或是中继链可能有多条，而节点只可以选择进入或是不进入分片/中继链，具体进入哪一条分片链是不可选择的，是根据节点的地址而定的。
为了数据传输过程的最小化，我们希望在分片扩展的时候，原来交易池、数据根的变化尽可能少，因此我们做如下的约定：
1. 在信标链上控制中继链的个数和中继链下每个分片链的个数
2. 中继链和信标链的个数总是2的指数次方
3. 扩展时，采用tik-tok原则，一次增加中继链，一次增加分片链
4. 扩展命令提前一个Epoch，即第N个Epoch中信标链发送的扩展标识后，在第N+1个Epoch中进行委员会选举，第N+2个Epoch中再正式开始。   
   在这个过程中需要作以下的处理：  
### 节点根据地址分片
在substrate里，每个节点都有一个地址，这个地址是公钥的哈希值（32字节）的后20字节，总计160位。我们通过不同的掩码长度来表征节点所属的分片，掩码的解释如下图：  
![](mask.png)
显然，我们定义掩码指数为L，那么
1. 掩码结果Mask(Addr,L)= Addr & ( 2<sup>L</sup> -1 )，**注意**示例中的掩码指数是5而不是4。
2. 两个后前L位长度的值相同的地址，掩码结果一致。

我们定义分片指数与掩码指数相关，假设中继链的分片指数为M，分片链的分片指数为N，那么：  
1. 中继个数为2<sup>M</sup>个，每个中继中分片个数为2<sup>N</sup>个
2. 总的分片数是2<sup>M+N</sup>个
3. 第K个中继的地址掩码为<sup>K</sup>
4. 第K个中继的第J个分片的地址掩码为<sup>K+J</sup>
5. 显示，当M和N确定后，即点可以使用自身的地址与掩码值方便地算出自身所属的中继和分片
   1. 所属中继 = Mask(Addr,K)
   2. 所属分片= Mask(Addr,K+J)
   
显然，当N增加时，中继链不变，节点所属分片变化，当M增加时，节点所属的中继和分片都有可能变化。
### 交易处理
在Pnyx中，交易分为多种，除了资产转移的交易外，还有一些交易（例如投票、存储证明）用于共识算法，此处讨论的交易主要是指资产转移交易。另外，对智能合约的执行也是属于资产转移交易的一种。  
交易根据发起者的地址决定属于哪一个分片；因此当分片扩展时，交易也需要转移到另外的分片中。目前我们都是考虑扩展，没有考虑收缩，收缩意味着网络出问题了，我们需要从另外一个方面再讨论这种情况的可能性与处理的必要性。本文只讨论扩展过程。
1. 如[分片选择](#span-id%22shardselection%22%e5%88%86%e7%89%87%e9%80%89%e6%8b%a9span)的步骤4所描述的那样，在分片开始扩展之前的一个Epoch，已经为此分片进行了一次委员会选举，直到上一个Epoch结束，从新的Epoch开始，所有的节点需要进入新的分片。
2. 当节点进入新的分片时，在交易池中，除了丢弃已经被区块打包的交易之外，交易池中还有不属于新分片的交易记录，因此需要丢弃这些不属于新区块的交易。
3. 出块者在打包的时候，如果在新的高度上打包了不属于这个分片的交易，将会被共识系统拒绝。
   
#### 区块回滚问题研究
假如扩展之前的最后一个区块是非最终确定化的，事实上，根据我们最终确定化的定义，它肯定是非最终确定化的，这个区块有可能被权重更高的区块回滚覆盖，下图是一个例子：
![](transaction_switch.png)  
在上图所述的例子中，在分片扩展时前一个区块时，节点A和B的交易池里和T1到T10的交易，已知分片扩展后，A和B将会进入不同的分片，而交易T1/T3.../T9将会进入A所在的分片，而交易T2/T4/...T10将会进入B所在的分片。由于A和B节点是一样的处理方式，我们以A为例进行讨论：
* A收到了新的区块（虚框部分），该区块中包含交易T1到T4，A从交易池中删除这4笔交易，然后由于Epoch到达，进入新的分片，然后删除不在此分片内的交易T6/T8/T10
* 过了一会儿，又收到新的权重更高的区块，该区块中包含交易T1/T2/T5/T6，因此节点A需要首先回滚原先区块中的交易T1到T4，交易池中的交易为（T1/T2/T3/T4/T5/T7/T9），然后重新处理交易T1/T2/T5/T6，处理完毕后，从交易池中删除交易T1/T2/T5/T6，因此交易池中剩余的交易为T3/T4/T7/T9，由于T4不属于新的分片，因此再次剔除T4。交易池中剩余的交易为T3/T7/T9。没有交易会被重复处理，也不会有交易丢失。
* 上述算法的核心是需要把被回滚区块中的交易重新放置到交易池中，而这就是正常区块分叉处理时的处理方案，因此不需要做另外的处理。
##### 极端情况
还是上图中，在切换时正好同一高度有两个区块，在极端情况下，假设分片A的大部分节点只收到虚框的区块，而分片B的大部分节点只收到了实框的区块，因此分片A中将继续处理T5/T7/T9，而分片B将处理T4/T8/T10交易，这时候，网络产生了分叉：  
![](fork.png)  
由于在分片扩展后，节点加入新的分片后，可能与原分片脱离，无法再获取到原分片中的消息，因此无法知晓对方使用的是哪个区块。再分析分片扩展的过程：当分片扩展时，一半的节点留在原分片内，另外有一半的节点进入新的分片。因此我们可以作如下的处理：
1. 在分片扩展开始时，新分片先进入waiting状态。
2. 在unstable状态下，新分片中的所有节点，都是只观测，不出块，直到原分片中的上一Epoch最后一个区块高度（图中的XX999高度）已经被最终确定化后,才退出waiting，进入正常状态。
3. 进入正常状态时，所有的节点以被最终确定化的区块为父节点进行出块计算。
因此，在分片扩展的时候，新分片将会延尽一段时间启动，这段时间内属于新分片的交易被打包的时间将会被延长，一般来说是一个区块时间，这个是可以接受的。

### 状态根
在区块链中，数据处理的结果以状态根的形式存在于区块中，对于单链来说，因为只有一个状态根，因此每次区块执行后更新此状态根。对于分片链，尤其是Pnyx支持了弹性分片后，情况略微有些不同。下图是一张典型的状态根更新的图：  
![](state_root.png)  
当分片进行动态扩展后，状态根的变化用下图来表示：  
![](state_trans.png)
在高度X999处，数据对象A和B有相应的值，而在产生分支后，在高度Y000和Z000处各有一个状态根，在Y000中，B对象更新了值，A还是原始的值；而在高度Z000处，A的值更新了，而B的值还是原来的（图示有点小错误，大体的意思表明了）。  
因此我们可以得到如下的结论：
1. 分片扩展后，每个分片链都单独更新属于该分片的存储节点的数据
2. 分片扩展后，每个分片链还能访问到不属于这个链的存储的数据，但是这个数据是在分片之前的旧值，不是最新值。
3. 推广可知，在一个分片链上可以或是修改不属于本分片的数据，但这是没有意义的。
4. 再推广可知，如果一个数据用某种分片标识作为前缀，就可以实现在不同的分片中产生不同的数据对象实例。而且这个对象实例会随着分片的扩展而自动增加。这一点非常对于可并行执行的智能合约非常重要，我们在跨分片合约这一节点详细讨论。
### 数据分离与删除
如上节所述，当分片扩展的时候，可以不删除原有的，属于其他链的数据，但是有一些关于链的信息需要重新计算，因此，合理的方案是把不属于这个链的数据也删除，而删除重新整理数据，删除不属于这个链的数据也有利于后续的[快速同步](#span-id%22fastsync%22%e5%bf%ab%e9%80%9f%e5%90%8c%e6%ad%a5span)。
系统提供分片扩展的事件给各个模块。  
数据的分离与删除由各个模块自行负责管理，在各个模块中分别描述。在分片时需要分离或是删除的数据，可以使用child_tries进行管理，降低数据分离和删除时的成本。

### 链管理
在有些情况下，不同类型链之间需要发送一些控制信息比如说信标链需要向中继发送中继和分片的分片指数M和N；而分片链需要向中继链上报自身节点的个数。这些数据的传递有两种两式，一种是在区块头中表示，另外是作为一种外源消息生成后发送。  
1. 在区块头中表示  
   以信标链在区块头中使用两个字节来分别表示M和N为例，当达到分片扩展的条件后，信标链的修改了M和N后，在区块头中表示，中继链检查到区块头的变化后，作相应的处理。在区块头中表示的模式存在一个问题：中继链难以追踪这个数据是何时发生变化的。
2. 生成外源信息  
   这种模式下，当信标链相要要求中继链使用新的M或N时，生成一个外源信息，广播发送给所有的中继链，中继链处理该消息。这种模式存在另外一个问题：信标链需要跟踪交易是否被处理，同样，多个中继链有可能有一些处理了，还有一些没有处理，也需要做另外的处理。
显然，第二种方案的扩展性更好一些，在需要增加控制策略的时候，不需要修改区块头，因此在Pnyx中采用方案2。按如下的方式进行：
1. 需要更新控制器，生成外源消息，广播发送给相应的对象
2. 在广播发送前，需要记录期望的处理者
3. 在相应的对象中处理外源消息，并且生成结果或是事件
4. 发送者监控处理者的区块消息，检查是否有处理消息，有就记录
5. 在一定区块后，如果还有处理者对象没有结果，重发消息给这些未处理的对象
由上可知，发送检查处理结果，重发这个过程需要多个区块来实现，为了所有接受对象执行控制命令的同步性，我们以Epoch为单位执行，即接受者先存储命令，等到下一个Epoch甚至是下下个Epoch时，再执行这些命令的结果。同时，发送者不会在Epoch的最后100个区块内发送控制命令。

### 区块高度问题
当分片扩展时，新的区块高度可以从0开始计数，也可以设置成从当前开始。 在Pnyx方案中，使用的是从分叉时开始的区块高度计数。这个方式使基于Epoch和区块高度的计算更容易。

### 附加说明
注意我们在此述的时候，并没有限制分片指数M和N的值，如果我们各使用一个字节来表征M和N的话，可以表示2<sup>256+256</sup>个分片。而事实上，由于Pnyx是线性可扩展分片系统，并不是无限可扩展的，因此随着分片数的扩大，分片间数据传输的带宽需求随着是随着分片数线性扩展的，因此分片指数M和N是受网络带宽限制的，网络分片数和带宽的关系见[此处]()。



# 委员会选举算法
委员会选举算法是在一个Epoch内，多个节点通过协作产生一个随机数，并且利用这个随机数在多个节点内选出一部分的过程。关于委员会选举算法的理论描述见[《委员会竞选》](../../Pnyx算法说明/cn/委员会竞选.md)。  
在Pnyx实现过程中，需要注意的在分片扩展的那个Epoch中，需要为分扩展后的两个分片选举出相应的委员会成员，因此需要选举出的委员会成员个数是原来的两倍，为了避免可选举出的委员会成员个数不足导致的分片失败，可以选择在节点数在最低委员会成员个数4倍的情况下，再开始分片。  
委员会选举把一个Epoch分成了5个阶段：Idle阶段/Submit阶段/Reveal阶段/Wait/Revealed阶段。在设计中，有意把Submit和Reveal阶段拉长，这个目的是防止出块者有意不把其他节点的竞选消息打包进区块，从而影响委员会成员。而Revealed阶段也会持续一段时间，这个是为了给新的委员会成员组建网络分组的时间。  
在Reveal和Revealed之间，增加了10个区块的延时，这个是为了防止Reveal的最后一个区块通过提交或是丢弃某个Reveal消息来调整最终的随机数值。  
在实现中，我们将一个Epoch的1000个区块分成了100/600/200/10/90，给submit更长的时间的另外一个好处是：由于参与委员会竞选是需要一定的准入门槛的（比如存储达到一定的要求），这样新达标的节点有更多的机会参与（比如在第550个区块才达标的节点也有机会参与竞选）。
节点只有达到系统规定的最低标准后，才能参与委员会竞选，一个节点最多可以参与3组委员会竞选（对应的分片、对应的中继和信标）,因此对应的pallet有三个实例。

委员会竞选有两条Callable
1. submit命令（包括EpochId,hash,chain_info)和签名
2. reveal命令 （包括EpochId,value,chain_info)和签名
数据存储：
submitted: 是一个{addr,hash}的数组
revealed:  是一个{addr,value}的值
committee: 竞选成功的委员会名单是addr的数组

## 委员会选举的最小值和最大值
我们通过奖励设置，使大量的节点除了参与分片之外，也愿意参与中继和信标链的出块工作。为了更进一步提高中继链和信标链的安全性，我们对委员会成员做以下的约定：
1. 委员会成员，在通常情况下，每10个Epoch有1次被选中的机会，即节点某一旦在某个Epoch当选为委员会成员后，后续的Epoch个区块都不会当选。
2. 如果参与委员会成员选举的节点不满足最低成员数要求，那么使用上一Epoch中参与选举，但是没有被选中的节点填补，如果还不满，继续往前一Epoch查询，直到满足要求或是10个Epoch为止
3. 如果10个Epoch也不满，就以所有的这些节点为委员会成员（极端情况，概率几乎可以忽略不计，或者是这条链没有价值，已经被抛弃了。

我们定义信标链和中继链委员会成员最低要求分别为4倍和2倍。

# 出块算法
Pnyx使用代理人投票算法从多个潜在的候选人中，选了一组符合条件的，按优先顺序进行投票。详细说明见[区块生成](../../Pnyx算法说明/cn/区块生成.md)
出块算法的实现有两个角色，每个角色都有两部分实现，Core和Frame部分

## 候选人
候选人角色
1. 监控新来的区块，根据区块的VRF结果计算自身的VRF值，
2. 计算链上的总能力值和自身的能力值
3. 根据这两个值算出出块的概率
4. 根据出块概率延时发送投票请求给委员会
5. 接收委员会的回应后，延时生成区块并且发送
## 代理人
1. 根据在Epoch中的序列号，计算自身是否属于代理人，如果是：
2. 计算等待投票请求的时间
3. 获取并且记录投票请求
4. 定时器到，向请求者发送投票结果
在这里面有几个需要特别说明的点：
1. 投票请求会在委员会中转发，委员会成员同样会根据这个投票的请求值，延时进行转发
2. 委员会同时具有转发上限，一段时间内只转发一定数量的投票请求，以此控制候选人节点不要抢先发送投票请求。
3. 代理人在每个区块的需要一段时间的等待时间，这段时间以代理人收到新区块为起始点计算，实际上，由于网络存在延时，某个委员会中的节点有可能在等待第N个区块的时候，收到了第N+1个区块的投票请求对于这种请求我们：
   1. 我们要求来源者出示证据：
      1. 证据是指该投票请求的上一区块的区块头、投票结果信息
   2. 如果来源请求者能够提供相应的证据，我们就认可该区块
4. 更进一步地，候选人在发送区块前，可以先向委员会节点发送一次投票结果信息，委员会成员中下一区块的代理人收到这个投票结果信息后，以收到的时间点作为下一区块的启始时间。
5. 更进一步地，任意一个委员会节点，在转发区块的实际内容前，如果该区块的投票结果没有被广播过，都会在委员会中广播一次投票结果信息。

## 奖励设计
从重要程度上来说，信标链>中继链>分片链，因此奖励设计的时候，采用4倍/2倍/1倍的奖励模式。
由于节点可以自由加入或是退出中继和信标链，因此如果在中继或是信标链中使全中继或是全链的总能力值，能够零延时提交投票请求的概率会比较小，因此使用所有参与竞选的节点的能力值之和作为总能力值计算。

# 区块设计
不同类型的链的区块内容和处理的方案不同，而事实上，一种类型链可能把另外一种类型的链的区块看成是自己的外源。例如中继链把自身管理的多个分片链的区块作为外源输入，根据区块中的跨分片交易的哈希重新调整，然后打包。下面我们按照不同链的类型来说明：
## 分片链
分片链处理以下类型的外源：
1. 资产转移交易
2. 中继区块
3. 委员会成员竞选
4. 合约调用
5. 存储部分
   1. 存储需求发布
   2. 存储服务发布
   3. 存储撮合
   4. 存储结果证明
   5. 扇区封包结果证明
## 中继链
中继链处理以下类型的外源：
1. 信标链区块
2. 中继区块
3. 委员会成员竞选
4. 合约调用
## 信标链
信标链处理以下类型的外源：
1. 中继区块
2. 委员会成员竞选
3. 合约调用
# 区块导入
## <span id="fast_sync">快速同步</span>
Pnyx通过代理和委员会成员来确定区块的权重，并且通过权重进行最终确定化。因此我们只需要确认权重的有效性就可以了。权重有效性通过如下方式判定：
1. 根据当前区块回溯，找到最近的一个已经最终确定化的区块（绿色区块）
2. 往后一个Epoch，寻找这个Epoch的委员会选举后的委员会名单（蓝色区块）
3. 判定通过2判1是否正确，如果正确：
4. 再往后一个Epoch，寻找这个Epoch的委员会选举结果
5. 通过4判断2是否正确，如果正确，继续往后执行，直到能够回溯匹配到创建区块的信息
![](fast_sync.png)
### 数据快照
当获得所有的区块头后，我们需要产生状态根对应的信息，这个称为数据重建，在以太坊及类似的系统中，这个是通过对每个区块的重放来实现数据的重建，这将会消耗大量的数据和时间。在Pnyx中，我们使用快照来实现快速数据重建：
1. 每隔100个slot，或者slot_no %100 == 0 时，我们对该数据进行快照存储
2. 当需要数据重建时，我们寻找到最近的，已经最终确定化的slot_no %100 == 0的区块
3. 根据这个区块中的state_root，从P2P存储系统中读取对应的数据然后进行重建
4. 从这个区块开始，读取所有的新区块内容，重放区块内的外源信息，建立数据。

**注意** 数据快照的间隔时间对系统的影响：
1. 间隔太短增加P2P系统中的数据存储量
2. 间隔太长重放生成时间增加

**注意2** P2P存储系统是非保证性的存储系统
1. P2P存储系统是非保证性的，其中的长时间不用的数据可能会被清除
2. 区块数据或是快照数据如果需要长期存储，通过链上发送存储需求和节点抢单进行存储。
   
# 跨分片合约
跨分片合约主要解决两个问题：
1. 数据如何分片存储
2. 在某个分片中执行的合约指令，如何访问其他分片上的数据
## 数据的分片存储
在Pnyx中，存储有两种，一种是合约内的全部变量，一种是函数内的局部变量：
* 合约内的全局变量：
1. 默认是数组，自动每个分片上都有一份
2. 默认是访问本分片的数据
3. 需要合局唯一存储的数据，使用"*"作为索引值  
4. 访问全局变量时，必须使用RW锁，否则不能保证数据的准确性

因此，要访问合约的全局变量时：  
1. 默认是访问本分片的
2. 如果访问其他分片和全局的数据，需要使用RW锁进行访问

* 函数内的局部变量  
由于其局部性的特点，不需要考虑分片问题。

## RW锁的实现
跨分片数据访问，使用RW锁进行，这意味着数据同时可以拥有一个写或多个读。 我们使用访问表来实现RW锁功能。  
### 访问表
访问表记录了资源的等待者的访问请求以及
### 写锁
当资源需要写时，调用写锁进行处理：
1. 如果该资源没有被写锁定，那么在访问表里写入该锁，然后允许继续执行
2. 如果该资源已经被写锁定，那么在访问表里添加{写请求，回调地址}对
释放写锁：
1. 当写锁被释放时

### 无锁读取
无锁读取在不需要精确结果的情况下使用，比如说有些统计结果

### 附加说明
跨分片读写会产生区块的外源事件，一共有4种外源事件
1. 写锁请求
2. 写锁返回
3. 读锁请求
4. 读锁返回
由此可知，跨分片数据读写是成本高昂的动作，因此需要尽可能的避免跨分片读写。
### 跨分片读写例子

# P2P存储
* 为了提高存储和访问的效率，我们设置P2P存储的地址和网络地址是异构的。
* 在第一版的实现中，我们使用改进版的以太坊swarm子项目实现了P2P存储，这个改进版的Swarm项目已经在自有的项目中正常运行12个月了，支持了每天数百T的流量和数百万的客户端。

# ANS（Ace Name Service)
ANS是名称解析系统，具有两个最基本的功能：
1. 为一个不超过32字节的名称注册一个所有者
2. 名称的所有者在这个名称之下，任意添加名称与哈希的对应关系。

# multiToken

# 原生SDK
## 去中心化存储
永不丢失的存储系统
任何人可以将任意大小的数据存依靠
## 直播
## VOD点播
## 易用的钱包
实现标准化的钱包接口（类似ERC20），然后把钱包的智能合约绑定到ANS上，就可以实现Send("alice","USDT",2000)的方式，同时还可以使用多签实现密码管理。
## 实时支付
实时支付需要首先开通并且抵押一部分代币在支付通道上，当然如果支付通道与信用体系结合，可以使用信用卡模式
## 离线支付
在实时支付的基础上，可以实现离线支付，离线支付是指支付方离线，接收方联网的情况 
## 自定义代币和预言机

# 可扩展应用
## VOD点播
## 平行链
## 去中心化交易所